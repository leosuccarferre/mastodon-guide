import * as React from "react";
export { default as createUseScreenVariants } from "./createUseScreenVariants";
export declare type StrictProps<T, TExpected> = Exclude<keyof T, keyof TExpected> extends never ? {} : "Unexpected extraneous props";
interface Variants {
    [vg: string]: any;
}
export declare type MultiChoiceArg<M extends string> = M | M[] | {
    [v in M]?: boolean;
};
export declare type SingleChoiceArg<M extends string> = M;
export declare type SingleBooleanChoiceArg<M extends string> = M | boolean;
interface OverrideTwiddle {
    wrapChildren?: (children: React.ReactNode) => React.ReactNode;
    wrap?: (node: React.ReactNode) => React.ReactNode;
}
export declare type DefaultOverride<C extends React.ElementType> = {
    type: "default";
    props?: Partial<React.ComponentProps<C>>;
} & OverrideTwiddle;
export declare type AsOverride<C extends React.ElementType> = {
    type: "as";
    as: C;
    props?: Partial<React.ComponentProps<C>>;
} & OverrideTwiddle;
export declare type RenderOverride<C extends React.ElementType> = {
    type: "render";
    render: (props: React.ComponentProps<C>) => React.ReactNode;
    props?: Partial<React.ComponentProps<C>>;
} & OverrideTwiddle;
export declare type Override<DefaultElementType extends React.ElementType> = DefaultOverride<DefaultElementType> | AsOverride<any> | RenderOverride<DefaultElementType>;
export declare type Overrides = Record<string, Flex<any>>;
export declare type Args = Record<string, any>;
export interface RenderOpts<V extends Variants, A extends Args, O extends Overrides> {
    variants: Partial<V>;
    args: Partial<A>;
    overrides: Partial<O>;
    forNode?: string;
}
export declare type Flex<DefaultElementType extends React.ElementType> = (Omit<DefaultOverride<DefaultElementType>, "type"> & {
    as?: never;
    render?: never;
}) | Omit<AsOverride<any>, "type"> | (Omit<RenderOverride<DefaultElementType>, "type"> & {
    as?: never;
}) | React.ReactChild | null | undefined | (Partial<React.ComponentProps<DefaultElementType>> & {
    wrap?: never;
    wrapChildren?: never;
    props?: never;
    as?: never;
    render?: never;
}) | ((props: React.ComponentProps<DefaultElementType>) => React.ReactNode);
export declare function hasVariant<V extends Variants>(variants: V | undefined, groupName: keyof V, variant: string): any;
export declare function createPlasmicElement<DefaultElementType extends React.ElementType>(override: Flex<DefaultElementType>, defaultRoot: DefaultElementType, defaultProps: Partial<React.ComponentProps<DefaultElementType>>, wrapChildrenInFlex?: boolean): React.ReactNode | null;
export declare function createPlasmicElementProxy<DefaultElementType extends React.ElementType>(defaultElement: DefaultElementType, props: Partial<React.ComponentProps<DefaultElementType>>, ...children: React.ReactNode[]): {} | null | undefined;
export declare function makeFragment(...children: React.ReactNode[]): React.FunctionComponentElement<{}>;
export declare const UNSET: unique symbol;
export declare function wrapWithClassName(element: React.ReactNode, className: string): React.DetailedReactHTMLElement<{
    key: string | number | undefined;
    className: string;
    style: {
        display: "grid";
    };
}, HTMLElement>;
export declare function PlasmicIcon(props: React.ComponentProps<"svg"> & {
    PlasmicIconType: React.ComponentType;
}): JSX.Element;
export declare function PlasmicSlot<T extends keyof JSX.IntrinsicElements = "div">(props: React.ComponentProps<T> & {
    as?: T;
    defaultContents?: React.ReactNode;
    value?: React.ReactNode;
}): JSX.Element | null;
export declare function PlasmicLink(props: any): JSX.Element;
export declare const Stack: (<T extends "symbol" | "object" | "big" | "link" | "small" | "sub" | "sup" | "track" | "progress" | "a" | "abbr" | "address" | "area" | "article" | "aside" | "audio" | "b" | "base" | "bdi" | "bdo" | "blockquote" | "body" | "br" | "button" | "canvas" | "caption" | "cite" | "code" | "col" | "colgroup" | "data" | "datalist" | "dd" | "del" | "details" | "dfn" | "dialog" | "div" | "dl" | "dt" | "em" | "embed" | "fieldset" | "figcaption" | "figure" | "footer" | "form" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "head" | "header" | "hgroup" | "hr" | "html" | "i" | "iframe" | "img" | "input" | "ins" | "kbd" | "label" | "legend" | "li" | "main" | "map" | "mark" | "menu" | "meta" | "meter" | "nav" | "noscript" | "ol" | "optgroup" | "option" | "output" | "p" | "param" | "picture" | "pre" | "q" | "rp" | "rt" | "ruby" | "s" | "samp" | "script" | "section" | "select" | "slot" | "source" | "span" | "strong" | "style" | "summary" | "table" | "tbody" | "td" | "template" | "textarea" | "tfoot" | "th" | "thead" | "time" | "title" | "tr" | "u" | "ul" | "var" | "video" | "wbr" | "circle" | "clipPath" | "defs" | "desc" | "ellipse" | "feBlend" | "feColorMatrix" | "feComponentTransfer" | "feComposite" | "feConvolveMatrix" | "feDiffuseLighting" | "feDisplacementMap" | "feDistantLight" | "feFlood" | "feFuncA" | "feFuncB" | "feFuncG" | "feFuncR" | "feGaussianBlur" | "feImage" | "feMerge" | "feMergeNode" | "feMorphology" | "feOffset" | "fePointLight" | "feSpecularLighting" | "feSpotLight" | "feTile" | "feTurbulence" | "filter" | "foreignObject" | "g" | "image" | "line" | "linearGradient" | "marker" | "mask" | "metadata" | "path" | "pattern" | "polygon" | "polyline" | "radialGradient" | "rect" | "stop" | "svg" | "switch" | "text" | "textPath" | "tspan" | "use" | "view" | "menuitem" | "keygen" | "noindex" | "webview" | "animate" | "animateMotion" | "animateTransform" | "feDropShadow" | "mpath" = "div">(props: {
    as?: T | undefined;
    hasGap?: boolean | undefined;
} & React.ComponentProps<T>) => React.ReactElement) & {
    div: React.FC<React.ClassAttributes<HTMLDivElement> & React.HTMLAttributes<HTMLDivElement> & {
        hasGap?: boolean | undefined;
    }>;
    a: React.FC<React.ClassAttributes<HTMLAnchorElement> & React.AnchorHTMLAttributes<HTMLAnchorElement> & {
        hasGap?: boolean | undefined;
    }>;
    button: React.FC<React.ClassAttributes<HTMLButtonElement> & React.ButtonHTMLAttributes<HTMLButtonElement> & {
        hasGap?: boolean | undefined;
    }>;
    h1: React.FC<React.ClassAttributes<HTMLHeadingElement> & React.HTMLAttributes<HTMLHeadingElement> & {
        hasGap?: boolean | undefined;
    }>;
    h2: React.FC<React.ClassAttributes<HTMLHeadingElement> & React.HTMLAttributes<HTMLHeadingElement> & {
        hasGap?: boolean | undefined;
    }>;
    h3: React.FC<React.ClassAttributes<HTMLHeadingElement> & React.HTMLAttributes<HTMLHeadingElement> & {
        hasGap?: boolean | undefined;
    }>;
    h4: React.FC<React.ClassAttributes<HTMLHeadingElement> & React.HTMLAttributes<HTMLHeadingElement> & {
        hasGap?: boolean | undefined;
    }>;
    h5: React.FC<React.ClassAttributes<HTMLHeadingElement> & React.HTMLAttributes<HTMLHeadingElement> & {
        hasGap?: boolean | undefined;
    }>;
    h6: React.FC<React.ClassAttributes<HTMLHeadingElement> & React.HTMLAttributes<HTMLHeadingElement> & {
        hasGap?: boolean | undefined;
    }>;
    label: React.FC<React.ClassAttributes<HTMLLabelElement> & React.LabelHTMLAttributes<HTMLLabelElement> & {
        hasGap?: boolean | undefined;
    }>;
    form: React.FC<React.ClassAttributes<HTMLFormElement> & React.FormHTMLAttributes<HTMLFormElement> & {
        hasGap?: boolean | undefined;
    }>;
    section: React.FC<React.ClassAttributes<HTMLElement> & React.HTMLAttributes<HTMLElement> & {
        hasGap?: boolean | undefined;
    }>;
    head: React.FC<React.ClassAttributes<HTMLHeadElement> & React.HTMLAttributes<HTMLHeadElement> & {
        hasGap?: boolean | undefined;
    }>;
    main: React.FC<React.ClassAttributes<HTMLElement> & React.HTMLAttributes<HTMLElement> & {
        hasGap?: boolean | undefined;
    }>;
    nav: React.FC<React.ClassAttributes<HTMLElement> & React.HTMLAttributes<HTMLElement> & {
        hasGap?: boolean | undefined;
    }>;
};
export declare const classNames: import("classnames/types").ClassNamesExport;
interface RenderFunc<V extends Variants, A extends Args, O extends Overrides> {
    (opts: RenderOpts<V, A, O>): React.ReactElement | null;
}
export declare abstract class Renderer<V extends Variants, A extends Args, O extends Overrides, Root extends keyof O> {
    protected variants: Partial<V>;
    protected args: Partial<A>;
    protected renderFunc: RenderFunc<V, A, O>;
    protected root: Root;
    constructor(variants: Partial<V>, args: Partial<A>, renderFunc: RenderFunc<V, A, O>, root: Root);
    protected abstract create(variants: Partial<V>, args: Partial<A>): Renderer<V, A, O, Root>;
    abstract getInternalVariantProps(): string[];
    abstract getInternalArgProps(): string[];
    withVariants(variants: Partial<V>): this;
    withArgs(args: Partial<A>): this;
    withOverrides(overrides: O): NodeRenderer<V, A, O>;
    forNode(node: keyof O): NodeRenderer<V, A, O>;
    render(): React.ReactElement<any, string | ((props: any) => React.ReactElement<any, string | any | (new (props: any) => React.Component<any, any, any>)> | null) | (new (props: any) => React.Component<any, any, any>)> | null;
}
export declare class NodeRenderer<V extends Variants, A extends Args, O extends Overrides> {
    protected renderFunc: RenderFunc<V, A, O>;
    protected name: string;
    protected variants: Partial<V>;
    protected args: Partial<A>;
    protected overrides: Partial<O>;
    constructor(renderFunc: RenderFunc<V, A, O>, name: string, variants: Partial<V>, args: Partial<A>, overrides: Partial<O>);
    withVariants(variants: Partial<V>): this;
    withArgs(args: Partial<A>): this;
    withOverrides(overrides: Partial<O>): this;
    render(): React.ReactElement<any, string | ((props: any) => React.ReactElement<any, string | any | (new (props: any) => React.Component<any, any, any>)> | null) | (new (props: any) => React.Component<any, any, any>)> | null;
}
export declare function deriveRenderOpts(props: Record<string, any>, config: {
    name: string;
    descendantNames: string[];
    internalVariantPropNames: string[];
    internalArgPropNames: string[];
}): {
    variants: Partial<Partial<Pick<Record<string, any>, string>>>;
    args: Partial<Partial<Pick<Record<string, any>, string>>>;
    overrides: Partial<Partial<Pick<Record<string, any>, string>>>;
};
export declare function ensureGlobalVariants<T extends Record<string, any>>(globalVariantValues: T): T;
export declare function pick<T, S extends keyof T>(obj: T, ...keys: S[]): Partial<Pick<T, S>>;
export declare function omit<T>(obj: T, ...keys: (keyof T)[]): Partial<T>;
declare function useFocused(opts: {
    isTextInput?: boolean;
}): (boolean | React.HTMLAttributes<HTMLElement>)[];
declare function useFocusVisible(opts: {
    isTextInput?: boolean;
}): (boolean | React.HTMLAttributes<HTMLElement>)[];
declare function useFocusedWithin(opts: {
    isTextInput?: boolean;
}): (boolean | React.HTMLAttributes<HTMLElement>)[];
declare function useFocusVisibleWithin(opts: {
    isTextInput?: boolean;
}): (boolean | React.HTMLAttributes<HTMLElement>)[];
declare function useHover(): (boolean | {
    onMouseEnter: (e: React.MouseEvent) => void;
    onMouseLeave: (e: React.MouseEvent) => void;
})[];
declare function usePressed(): (boolean | {
    onMouseDown: (e: React.MouseEvent) => void;
    onMouseUp: (e: React.MouseEvent) => void;
})[];
declare const TRIGGER_TO_HOOK: {
    readonly useHover: typeof useHover;
    readonly useFocused: typeof useFocused;
    readonly useFocusVisible: typeof useFocusVisible;
    readonly useFocusedWithin: typeof useFocusedWithin;
    readonly useFocusVisibleWithin: typeof useFocusVisibleWithin;
    readonly usePressed: typeof usePressed;
};
declare type TriggerType = keyof typeof TRIGGER_TO_HOOK;
interface TriggerOpts {
    isTextInput?: boolean;
}
/**
 * Installs argment trigger. All the useTrigger calls must use hardcoded `trigger` arg,
 * as it's not valid to install variable React hooks!
 */
export declare function useTrigger(trigger: TriggerType, opts: TriggerOpts): [boolean, React.HTMLAttributes<HTMLElement>];
