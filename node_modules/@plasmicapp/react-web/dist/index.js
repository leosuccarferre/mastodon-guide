"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTrigger = exports.omit = exports.pick = exports.ensureGlobalVariants = exports.deriveRenderOpts = exports.NodeRenderer = exports.Renderer = exports.classNames = exports.Stack = exports.PlasmicLink = exports.PlasmicSlot = exports.PlasmicIcon = exports.wrapWithClassName = exports.UNSET = exports.makeFragment = exports.createPlasmicElementProxy = exports.createPlasmicElement = exports.hasVariant = void 0;
var focus_1 = require("@react-aria/focus");
var classnames_1 = __importDefault(require("classnames"));
var React = __importStar(require("react"));
function hasVariant(variants, groupName, variant) {
    if (variants == null) {
        return false;
    }
    var groupVariants = variants[groupName];
    if (groupVariants == null) {
        return false;
    }
    else if (groupVariants === true) {
        return variant === groupName;
    }
    else if (groupVariants === false) {
        return false;
    }
    else if (Array.isArray(groupVariants)) {
        return groupVariants.includes(variant);
    }
    else if (typeof groupVariants === "string") {
        return groupVariants === variant;
    }
    else {
        return (groupVariants[variant] !== undefined && groupVariants[variant] !== false);
    }
}
exports.hasVariant = hasVariant;
function wrapFlexContainerChildren(children, hasGap) {
    // We need to always wrap the children, even if there are no gaps, because
    // otherwise if we toggle between with and without gap, React reconciliation
    // will blow away the children tree and all state if we switch from having
    // a wrapper and not.
    var className = hasGap ? "__wab_flex-container" : "__wab_passthrough";
    if (!children) {
        return null;
    }
    else if (Array.isArray(children)) {
        return React.createElement.apply(React, __spreadArrays(["div", { className: className }], children));
    }
    else {
        return React.createElement("div", { className: className }, children);
    }
}
function createPlasmicElement(override, defaultRoot, defaultProps, wrapChildrenInFlex) {
    var override2 = deriveOverride(override);
    var props = mergeOverrideProps(defaultProps, override2.props);
    if (override2.type === "render") {
        return override2.render(props);
    }
    var root = defaultRoot;
    if (override2.type === "as" && override2.as) {
        if (defaultRoot === exports.Stack) {
            // If there was an "as" override specified, but the default type is
            // a Stack, then we don't want to switch to using "as" as the root,
            // because then we'd lose the flex wrapper that Stack provides.
            // Instead, we specify the "as" as the "as" prop to Stack.
            props.as = override2.as;
        }
        else {
            root = override2.as;
        }
    }
    var children = props.children;
    if (override2.wrapChildren) {
        children = override2.wrapChildren(ensureNotArray(children));
    }
    if (wrapChildrenInFlex) {
        // For legacy, we still support data-plasmic-wrap-flex-children
        children = wrapFlexContainerChildren(children, true);
    }
    var result = createElementWithChildren(root, props, children);
    if (override2.wrap) {
        result = override2.wrap(result);
    }
    return result;
}
exports.createPlasmicElement = createPlasmicElement;
function createElementWithChildren(elementType, props, children) {
    if (Array.isArray(children)) {
        return React.createElement.apply(React, __spreadArrays([elementType,
            props], children));
    }
    else if (children || "children" in props) {
        // Only call React.createElement with `children` if there are actual children,
        // or if there was an explicit (albeit undefined) children passed via
        // props.  Otherwise, if you pass `undefined` as the children argument
        // to React.createElement, the created element will have prop {children: undefined}.
        // If the `root` is an PlasmicGeneratedComponent, and these props with {children: undefined}
        // are used, then it will be taken as a `children` override, and will thus blank out
        // everything under the root node.
        return React.createElement(elementType, props, children);
    }
    else {
        return React.createElement(elementType, props);
    }
}
function ensureNotArray(children) {
    if (Array.isArray(children)) {
        return React.createElement.apply(React, __spreadArrays([React.Fragment, {}], children));
    }
    else {
        return children;
    }
}
// We use data-plasmic-XXX attributes for custom properties since Typescript doesn't
// support type check on @jsx pragma. See https://github.com/microsoft/TypeScript/issues/21699
// for more info.
var seenElements = new Map();
function createPlasmicElementProxy(defaultElement, props) {
    // We use seenElements to keep track of elements that has been rendered by
    // createPlasmicElementProxy().  When a JSX tree is evaluated, the JSX factory
    // is invoked from the leaf to the root as the last call.  So we can store
    // all the elements we've created until we encounter the leaf, at which point
    // we will clear this map.  We are guaranteed that this map will only contain
    // elements from one Plasmic* component at a time, because we're just creating
    // elements and not "rendering" at this point; even if this JSX tree references
    // other Plasmic* elements, we'll just create an element referencing that component,
    // rather than following into the content of that component.
    //
    // TODO: is this ConcurrentMode friendly?
    var _a;
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    if (props == null) {
        props = {};
    }
    var name = props["data-plasmic-name"];
    var isRoot = props["data-plasmic-root"];
    var forNodeName = props["data-plasmic-for-node"];
    delete props["data-plasmic-name"];
    delete props["data-plasmic-root"];
    delete props["data-plasmic-for-node"];
    var element = createPlasmicElementFromJsx.apply(void 0, __spreadArrays([defaultElement,
        props], children));
    if (name) {
        seenElements.set(name, element);
    }
    if (isRoot) {
        // If this is the root, and we requested a specific node by specifying data-plasmic-for-node,
        // then return that node instead
        var forNode = forNodeName
            ? (_a = seenElements.get(forNodeName)) !== null && _a !== void 0 ? _a : null : element;
        // Clear out the seenElements map, as we're done rendering this Plasmic* component.
        seenElements.clear();
        return forNode;
    }
    return element;
}
exports.createPlasmicElementProxy = createPlasmicElementProxy;
function createPlasmicElementFromJsx(defaultElement, props) {
    var _a;
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    var override = props["data-plasmic-override"];
    var wrapFlexChild = props["data-plasmic-wrap-flex-child"];
    var triggerProps = ((_a = props["data-plasmic-trigger-props"]) !== null && _a !== void 0 ? _a : []);
    delete props["data-plasmic-override"];
    delete props["data-plasmic-wrap-flex-child"];
    delete props["data-plasmic-trigger-props"];
    return createPlasmicElement(override, defaultElement, mergeProps.apply(void 0, __spreadArrays([props, children.length === 0 ? {} : { children: children }], triggerProps)), wrapFlexChild);
}
function makeFragment() {
    var children = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        children[_i] = arguments[_i];
    }
    return React.createElement.apply(React, __spreadArrays([React.Fragment, {}], children));
}
exports.makeFragment = makeFragment;
var NONE = Symbol("NONE");
function mergeProps(props) {
    var restProps = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        restProps[_i - 1] = arguments[_i];
    }
    var result = __assign({}, props);
    for (var _a = 0, restProps_1 = restProps; _a < restProps_1.length; _a++) {
        var rest = restProps_1[_a];
        for (var _b = 0, _c = Object.keys(rest); _b < _c.length; _b++) {
            var key = _c[_b];
            result[key] = mergePropVals(key, result[key], rest[key]);
        }
    }
    return result;
}
function mergePropVals(name, val1, val2) {
    if (val1 === NONE || val2 === NONE) {
        // The NONE sentinel always skips all merging and returns null
        return null;
    }
    else if (val1 == null) {
        // If either of them is nil, prefer the other
        return val2;
    }
    else if (val2 == null) {
        return val1;
    }
    else if (typeof val1 !== typeof val2) {
        // If the type of the two values are different, then no way to merge them.
        // Prefer val2.
        return val2;
    }
    else if (name === "className") {
        // Special case for className -- always combine both class names
        return exports.classNames(val1, val2);
    }
    else if (name === "style") {
        // Special case for style -- always shallow-merge style dicts
        return __assign(__assign({}, val1), val2);
    }
    else if (name.startsWith("on") && typeof val1 === "function") {
        // Special case for event handlers -- always call both handlers
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var res;
            if (typeof val1 === "function") {
                res = val1.apply(void 0, args);
            }
            if (typeof val2 === "function") {
                res = val2.apply(void 0, args);
            }
            return res;
        };
    }
    else {
        // For all else, prefer val2
        return val2;
    }
}
exports.UNSET = Symbol("UNSET");
function mergeOverrideProps(defaults, overrides) {
    if (!overrides) {
        return defaults;
    }
    var result = __assign({}, defaults);
    for (var _i = 0, _a = Object.keys(overrides); _i < _a.length; _i++) {
        var key = _a[_i];
        var defaultVal = defaults[key];
        var overrideVal = overrides[key];
        if (overrideVal === exports.UNSET) {
            delete result[key];
        }
        else {
            // We use the NONE sentinel of the overrideVal is nil, and is not one of the
            // props that we merge by default -- which are className, style, and
            // event handlers.  This means for all other "normal" props -- like children,
            // title, etc -- a nil value will unset the default.
            if (overrideVal == null &&
                key !== "className" &&
                key !== "style" &&
                !(key.startsWith("on") && typeof defaultVal === "function")) {
                overrideVal = NONE;
            }
            result[key] = mergePropVals(key, defaultVal, overrideVal);
        }
    }
    return result;
}
function wrapWithClassName(element, className) {
    var key = React.isValidElement(element)
        ? element.key || undefined
        : undefined;
    return React.createElement("div", {
        key: key,
        className: className,
        style: {
            display: "grid",
        },
    }, element);
}
exports.wrapWithClassName = wrapWithClassName;
function PlasmicIcon(props) {
    var PlasmicIconType = props.PlasmicIconType, rest = __rest(props, ["PlasmicIconType"]);
    return React.createElement(PlasmicIconType, __assign({}, rest));
}
exports.PlasmicIcon = PlasmicIcon;
function maybeAsString(node) {
    // Unwrap fragments
    if (React.isValidElement(node) && node.type === React.Fragment) {
        return maybeAsString(node.props.children);
    }
    if (typeof node === "string") {
        return node;
    }
    if (Array.isArray(node) && node.length === 1 && typeof node[0] === "string") {
        return node[0];
    }
    return undefined;
}
function PlasmicSlot(props) {
    var as = props.as, defaultContents = props.defaultContents, value = props.value, rest = __rest(props, ["as", "defaultContents", "value"]);
    var content = value === undefined ? defaultContents : value;
    if (!content || (Array.isArray(content) && content.length === 0)) {
        return null;
    }
    // If the content is a raw string, then we need to wrap the raw string
    // into an element, in case the slot is inside a flex-gap
    // container (you cannot apply margin to just a text node).
    var maybeString = maybeAsString(content);
    if (maybeString) {
        content = React.createElement("div", { className: "__wab_slot-string-wrapper" }, maybeString);
    }
    var nonEmptyProps = Object.keys(rest).filter(function (p) { return !!rest[p]; });
    if (nonEmptyProps.length === 0) {
        // No attrs to apply to the slot (which means the slot is unstyled), then
        // just render the content directly; no need for style wrapper.
        return React.createElement(React.Fragment, null, content);
    }
    return React.createElement(as || "div", mergeProps({ className: "__wab_slot" }, rest), content);
}
exports.PlasmicSlot = PlasmicSlot;
function isInternalHref(href) {
    return /^\/(?!\/)/.test(href);
}
function PlasmicLink(props) {
    if (props.platform === "nextjs") {
        var nextjsProps = [
            "href",
            "replace",
            "scroll",
            "shallow",
            "passHref",
            "prefetch",
            "locale",
        ];
        return React.createElement(props.component, pick.apply(void 0, __spreadArrays([props], nextjsProps)), React.createElement("a", __assign({}, omit.apply(void 0, __spreadArrays([props, "component", "platform"], nextjsProps)))));
    }
    if (props.platform === "gatsby" && isInternalHref(props.href)) {
        return React.createElement(props.component, __assign(__assign({}, omit(props, "component", "platform", "href")), { to: props.href }));
    }
    return React.createElement("a", __assign({}, omit(props, "component", "platform")));
}
exports.PlasmicLink = PlasmicLink;
function renderStack(as, props, hasGap, ref) {
    var children = props.children, rest = __rest(props, ["children"]);
    var wrappedChildren = wrapFlexContainerChildren(children, hasGap !== null && hasGap !== void 0 ? hasGap : false);
    return createElementWithChildren(as, __assign({ ref: ref }, rest), wrappedChildren);
}
function FlexStack_(props, outerRef) {
    var as = props.as, hasGap = props.hasGap, rest = __rest(props, ["as", "hasGap"]);
    return renderStack(as !== null && as !== void 0 ? as : "div", rest, hasGap, outerRef);
}
var FlexStack = React.forwardRef(FlexStack_);
var makeStackImpl = function (as) {
    return React.forwardRef(function (props, ref) {
        var hasGap = props.hasGap, rest = __rest(props, ["hasGap"]);
        return renderStack(as, rest, hasGap, ref);
    });
};
exports.Stack = Object.assign(FlexStack, {
    div: makeStackImpl("div"),
    a: makeStackImpl("a"),
    button: makeStackImpl("button"),
    h1: makeStackImpl("h1"),
    h2: makeStackImpl("h2"),
    h3: makeStackImpl("h3"),
    h4: makeStackImpl("h4"),
    h5: makeStackImpl("h5"),
    h6: makeStackImpl("h6"),
    label: makeStackImpl("label"),
    form: makeStackImpl("form"),
    section: makeStackImpl("section"),
    head: makeStackImpl("head"),
    main: makeStackImpl("main"),
    nav: makeStackImpl("nav"),
});
function deriveOverride(x) {
    if (!x) {
        // undefined Binding is an empty Binding
        return {
            type: "default",
            props: {},
        };
    }
    else if (isReactNode(x)) {
        // If ReactNode, then assume this is the children
        return {
            type: "default",
            props: {
                children: x,
            },
        };
    }
    else if (typeof x === "object") {
        // If any of the overrideKeys is a key of this object, then assume
        // this is a full Override
        if ("as" in x) {
            return __assign(__assign({}, x), { props: x.props || {}, type: "as" });
        }
        else if ("render" in x) {
            return __assign(__assign({}, x), { type: "render" });
        }
        else if ("props" in x) {
            return __assign(__assign({}, x), { props: x.props || {}, type: "default" });
        }
        else if (isSubset(Object.keys(x), ["wrap", "wrapChildren"])) {
            // Only twiddling functions present, so assume no props overrides
            // (otherwise we'd assume these were props).
            return __assign(__assign({}, x), { props: {}, type: "default" });
        }
        // Else, assume this is just a props object.
        return {
            type: "default",
            props: x,
        };
    }
    else if (typeof x === "function") {
        return {
            type: "render",
            render: x,
        };
    }
    throw new Error("Unexpected override: " + x);
}
function isSubset(a1, a2) {
    return a1.every(function (x) { return a2.includes(x); });
}
function isReactNode(x) {
    return (typeof x === "string" || typeof x === "number" || React.isValidElement(x));
}
exports.classNames = classnames_1.default;
var Renderer = /** @class */ (function () {
    function Renderer(variants, args, renderFunc, root) {
        this.variants = variants;
        this.args = args;
        this.renderFunc = renderFunc;
        this.root = root;
    }
    Renderer.prototype.withVariants = function (variants) {
        return this.create(mergeVariants(this.variants, variants), this.args);
    };
    Renderer.prototype.withArgs = function (args) {
        return this.create(this.variants, mergeArgs(this.args, args));
    };
    Renderer.prototype.withOverrides = function (overrides) {
        return this.forNode(this.root).withOverrides(overrides);
    };
    Renderer.prototype.forNode = function (node) {
        return new NodeRenderer(this.renderFunc, node, this.variants, this.args, {});
    };
    Renderer.prototype.render = function () {
        return this.forNode(this.root).render();
    };
    return Renderer;
}());
exports.Renderer = Renderer;
var NodeRenderer = /** @class */ (function () {
    function NodeRenderer(renderFunc, name, variants, args, overrides) {
        this.renderFunc = renderFunc;
        this.name = name;
        this.variants = variants;
        this.args = args;
        this.overrides = overrides;
    }
    NodeRenderer.prototype.withVariants = function (variants) {
        return new NodeRenderer(this.renderFunc, this.name, mergeVariants(this.variants, variants), this.args, this.overrides);
    };
    NodeRenderer.prototype.withArgs = function (args) {
        return new NodeRenderer(this.renderFunc, this.name, this.variants, mergeArgs(this.args, args), this.overrides);
    };
    NodeRenderer.prototype.withOverrides = function (overrides) {
        return new NodeRenderer(this.renderFunc, this.name, this.variants, this.args, mergeFlexOverrides(this.overrides, overrides));
    };
    NodeRenderer.prototype.render = function () {
        return this.renderFunc({
            variants: this.variants,
            overrides: this.overrides,
            args: this.args,
            forNode: this.name,
        });
    };
    return NodeRenderer;
}());
exports.NodeRenderer = NodeRenderer;
function mergeVariants(v1, v2) {
    return __assign(__assign({}, v1), v2);
}
function mergeArgs(a1, a2) {
    return __assign(__assign({}, a1), a2);
}
function mergeFlexOverrides(o1, o2) {
    var keys = Array.from(new Set(__spreadArrays(Object.keys(o1), Object.keys(o2))));
    var merged = {};
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        merged[key] = mergeFlexOverride(o1[key], o2[key]);
    }
    return merged;
}
function chainSingleArgFuncs() {
    var funcs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        funcs[_i] = arguments[_i];
    }
    if (funcs.length === 0) {
        return undefined;
    }
    return function (arg) {
        var res = arg;
        for (var _i = 0, funcs_1 = funcs; _i < funcs_1.length; _i++) {
            var func = funcs_1[_i];
            res = func(res);
        }
        return res;
    };
}
function mergeFlexOverride(fo1, fo2) {
    var _a, _b;
    if (!fo1) {
        return fo2;
    }
    if (!fo2) {
        return fo1;
    }
    var o1 = deriveOverride(fo1);
    var o2 = deriveOverride(fo2);
    var wrap = chainSingleArgFuncs.apply(void 0, [o1.wrap, o2.wrap].filter(notNil));
    var wrapChildren = chainSingleArgFuncs.apply(void 0, [o1.wrapChildren, o2.wrapChildren].filter(notNil));
    // "render" type always takes precedence, but we still merge the props
    var props = mergeOverrideProps((_a = o1.props) !== null && _a !== void 0 ? _a : {}, o2.props);
    if (o2.type === "render") {
        return {
            render: o2.render,
            props: props,
            wrap: wrap,
            wrapChildren: wrapChildren,
        };
    }
    if (o1.type === "render") {
        return {
            render: o1.render,
            props: props,
            wrap: wrap,
            wrapChildren: wrapChildren,
        };
    }
    // "as" will take precedence
    var as = (_b = (o2.type === "as" ? o2.as : undefined)) !== null && _b !== void 0 ? _b : (o1.type === "as" ? o1.as : undefined);
    return __assign({ props: props,
        wrap: wrap,
        wrapChildren: wrapChildren }, (as ? { as: as } : {}));
}
function deriveRenderOpts(props, config) {
    var _a;
    var _b, _c, _d;
    var name = config.name, descendantNames = config.descendantNames, internalVariantPropNames = config.internalVariantPropNames, internalArgPropNames = config.internalArgPropNames;
    var reservedPropNames = ["variants", "args", "overrides"];
    var variants = mergeVariants(omit.apply(void 0, __spreadArrays([pick.apply(void 0, __spreadArrays([props], internalVariantPropNames))], reservedPropNames)), (_b = props.variants) !== null && _b !== void 0 ? _b : {});
    var args = mergeArgs(omit.apply(void 0, __spreadArrays([pick.apply(void 0, __spreadArrays([props], internalArgPropNames))], reservedPropNames)), (_c = props.args) !== null && _c !== void 0 ? _c : {});
    var overrides = mergeFlexOverrides(omit.apply(void 0, __spreadArrays([pick.apply(void 0, __spreadArrays([props], descendantNames))], internalArgPropNames, internalVariantPropNames, reservedPropNames)), (_d = props.overrides) !== null && _d !== void 0 ? _d : {});
    var leftoverProps = omit.apply(void 0, __spreadArrays([props,
        "variants",
        "args",
        "overrides"], descendantNames, internalVariantPropNames, internalArgPropNames));
    if (Object.keys(leftoverProps).length > 0) {
        overrides = mergeFlexOverrides(overrides, (_a = {},
            _a[name] = {
                props: leftoverProps,
            },
            _a));
    }
    return { variants: variants, args: args, overrides: overrides };
}
exports.deriveRenderOpts = deriveRenderOpts;
function ensureGlobalVariants(globalVariantValues) {
    Object.entries(globalVariantValues).forEach(function (_a) {
        var key = _a[0], value = _a[1];
        if (value === "PLEASE_RENDER_INSIDE_PROVIDER") {
            var providerName = key === "screen"
                ? "ScreenVariantProvider"
                : "" + key[0].toUpperCase() + key.substring(1) + "Context.Provider";
            throw new Error("Plasmic context value for global variant \"" + key + "\" was not provided; please use " + providerName + " at the root of your React app. Learn More: https://www.plasmic.app/learn/other-assets/#global-variants");
        }
    });
    return globalVariantValues;
}
exports.ensureGlobalVariants = ensureGlobalVariants;
function notNil(x) {
    return x != null;
}
function pick(obj) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var res = {};
    for (var _a = 0, keys_2 = keys; _a < keys_2.length; _a++) {
        var key = keys_2[_a];
        if (key in obj) {
            res[key] = obj[key];
        }
    }
    return res;
}
exports.pick = pick;
function omit(obj) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var res = {};
    for (var _a = 0, _b = Object.keys(obj); _a < _b.length; _a++) {
        var key = _b[_a];
        if (!keys.includes(key)) {
            res[key] = obj[key];
        }
    }
    return res;
}
exports.omit = omit;
function useFocused(opts) {
    var _a = focus_1.useFocusRing({
        within: false,
        isTextInput: opts.isTextInput,
    }), isFocused = _a.isFocused, focusProps = _a.focusProps;
    return [isFocused, focusProps];
}
function useFocusVisible(opts) {
    var _a = focus_1.useFocusRing({
        within: false,
        isTextInput: opts.isTextInput,
    }), isFocusVisible = _a.isFocusVisible, focusProps = _a.focusProps;
    return [isFocusVisible, focusProps];
}
function useFocusedWithin(opts) {
    var _a = focus_1.useFocusRing({
        within: true,
        isTextInput: opts.isTextInput,
    }), isFocused = _a.isFocused, focusProps = _a.focusProps;
    return [isFocused, focusProps];
}
function useFocusVisibleWithin(opts) {
    var _a = focus_1.useFocusRing({
        within: true,
        isTextInput: opts.isTextInput,
    }), isFocusVisible = _a.isFocusVisible, focusProps = _a.focusProps;
    return [isFocusVisible, focusProps];
}
function useHover() {
    var _a = React.useState(false), isHover = _a[0], setHover = _a[1];
    return [
        isHover,
        {
            onMouseEnter: function (e) { return setHover(true); },
            onMouseLeave: function (e) { return setHover(false); },
        },
    ];
}
function usePressed() {
    var _a = React.useState(false), isPressed = _a[0], setPressed = _a[1];
    return [
        isPressed,
        {
            onMouseDown: function (e) { return setPressed(true); },
            onMouseUp: function (e) { return setPressed(false); },
        },
    ];
}
var TRIGGER_TO_HOOK = {
    useHover: useHover,
    useFocused: useFocused,
    useFocusVisible: useFocusVisible,
    useFocusedWithin: useFocusedWithin,
    useFocusVisibleWithin: useFocusVisibleWithin,
    usePressed: usePressed,
};
/**
 * Installs argment trigger. All the useTrigger calls must use hardcoded `trigger` arg,
 * as it's not valid to install variable React hooks!
 */
function useTrigger(trigger, opts) {
    return TRIGGER_TO_HOOK[trigger](opts);
}
exports.useTrigger = useTrigger;
